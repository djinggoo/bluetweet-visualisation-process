{"ast":null,"code":"import _objectWithoutProperties from \"/Users/macintosh/tugas-big-data/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"/Users/macintosh/tugas-big-data/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/Users/macintosh/tugas-big-data/src/component/chartComponent.js\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Chart from 'chart.js';\nimport isEqual from 'lodash/isEqual';\nimport keyBy from 'lodash/keyBy';\n\nclass ChartComponent extends React.Component {\n  constructor() {\n    super();\n\n    this.handleOnClick = event => {\n      const instance = this.chartInstance;\n      const _this$props = this.props,\n            getDatasetAtEvent = _this$props.getDatasetAtEvent,\n            getElementAtEvent = _this$props.getElementAtEvent,\n            getElementsAtEvent = _this$props.getElementsAtEvent,\n            onElementsClick = _this$props.onElementsClick;\n      getDatasetAtEvent && getDatasetAtEvent(instance.getDatasetAtEvent(event), event);\n      getElementAtEvent && getElementAtEvent(instance.getElementAtEvent(event), event);\n      getElementsAtEvent && getElementsAtEvent(instance.getElementsAtEvent(event), event);\n      onElementsClick && onElementsClick(instance.getElementsAtEvent(event), event); // Backward compatibility\n    };\n\n    this.ref = element => {\n      this.element = element;\n    };\n\n    this.chartInstance = undefined;\n  }\n\n  componentDidMount() {\n    this.renderChart();\n  }\n\n  componentDidUpdate() {\n    if (this.props.redraw) {\n      this.destroyChart();\n      this.renderChart();\n      return;\n    }\n\n    this.updateChart();\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const _this$props2 = this.props,\n          redraw = _this$props2.redraw,\n          type = _this$props2.type,\n          options = _this$props2.options,\n          plugins = _this$props2.plugins,\n          legend = _this$props2.legend,\n          height = _this$props2.height,\n          width = _this$props2.width;\n\n    if (nextProps.redraw === true) {\n      return true;\n    }\n\n    if (height !== nextProps.height || width !== nextProps.width) {\n      return true;\n    }\n\n    if (type !== nextProps.type) {\n      return true;\n    }\n\n    if (!isEqual(legend, nextProps.legend)) {\n      return true;\n    }\n\n    if (!isEqual(options, nextProps.options)) {\n      return true;\n    }\n\n    const nextData = this.transformDataProp(nextProps);\n\n    if (!isEqual(this.shadowDataProp, nextData)) {\n      return true;\n    }\n\n    return !isEqual(plugins, nextProps.plugins);\n  }\n\n  componentWillUnmount() {\n    this.destroyChart();\n  }\n\n  transformDataProp(props) {\n    const data = props.data;\n\n    if (typeof data == 'function') {\n      const node = this.element;\n      return data(node);\n    } else {\n      return data;\n    }\n  } // Chart.js directly mutates the data.dataset objects by adding _meta proprerty\n  // this makes impossible to compare the current and next data changes\n  // therefore we memoize the data prop while sending a fake to Chart.js for mutation.\n  // see https://github.com/chartjs/Chart.js/blob/master/src/core/core.controller.js#L615-L617\n\n\n  memoizeDataProps() {\n    if (!this.props.data) {\n      return;\n    }\n\n    const data = this.transformDataProp(this.props);\n    this.shadowDataProp = _objectSpread({}, data, {\n      datasets: data.datasets && data.datasets.map(set => {\n        return _objectSpread({}, set);\n      })\n    });\n    this.saveCurrentDatasets(); // to remove the dataset metadata from this chart when the chart is destroyed\n\n    return data;\n  } // checkDatasets(datasets) {\n  //   const isDev = NODE_ENV !== 'production' && NODE_ENV !== 'prod';\n  //   const usingCustomKeyProvider = this.props.datasetKeyProvider !== ChartComponent.getLabelAsKey;\n  //   const multipleDatasets = datasets.length > 1;\n  //   if (isDev && multipleDatasets && !usingCustomKeyProvider) {\n  //     let shouldWarn = false;\n  //     datasets.forEach((dataset) => {\n  //       if (!dataset.label) {\n  //         shouldWarn = true;\n  //       }\n  //     });\n  //     if (shouldWarn) {\n  //       console.error('[react-chartjs-2] Warning: Each dataset needs a unique key. By default, the \"label\" property on each dataset is used. Alternatively, you may provide a \"datasetKeyProvider\" as a prop that returns a unique key.');\n  //     }\n  //   }\n  // }\n\n\n  getCurrentDatasets() {\n    return this.chartInstance && this.chartInstance.config.data && this.chartInstance.config.data.datasets || [];\n  }\n\n  saveCurrentDatasets() {\n    this.datasets = this.datasets || {};\n    var currentDatasets = this.getCurrentDatasets();\n    currentDatasets.forEach(d => {\n      this.datasets[this.props.datasetKeyProvider(d)] = d;\n    });\n  }\n\n  updateChart() {\n    const options = this.props.options;\n    const data = this.memoizeDataProps(this.props);\n    if (!this.chartInstance) return;\n\n    if (options) {\n      this.chartInstance.options = Chart.helpers.configMerge(this.chartInstance.options, options);\n    } // Pipe datasets to chart instance datasets enabling\n    // seamless transitions\n\n\n    let currentDatasets = this.getCurrentDatasets();\n    const nextDatasets = data.datasets || [];\n    this.checkDatasets(currentDatasets);\n    const currentDatasetsIndexed = keyBy(currentDatasets, this.props.datasetKeyProvider); // We can safely replace the dataset array, as long as we retain the _meta property\n    // on each dataset.\n\n    this.chartInstance.config.data.datasets = nextDatasets.map(next => {\n      const current = currentDatasetsIndexed[this.props.datasetKeyProvider(next)];\n\n      if (current && current.type === next.type && next.data) {\n        // Be robust to no data. Relevant for other update mechanisms as in chartjs-plugin-streaming.\n        // The data array must be edited in place. As chart.js adds listeners to it.\n        current.data.splice(next.data.length);\n        next.data.forEach((point, pid) => {\n          current.data[pid] = next.data[pid];\n        });\n\n        const data = next.data,\n              otherProps = _objectWithoutProperties(next, [\"data\"]); // Merge properties. Notice a weakness here. If a property is removed\n        // from next, it will be retained by current and never disappears.\n        // Workaround is to set value to null or undefined in next.\n\n\n        return _objectSpread({}, current, {}, otherProps);\n      } else {\n        return next;\n      }\n    });\n\n    const datasets = data.datasets,\n          rest = _objectWithoutProperties(data, [\"datasets\"]);\n\n    this.chartInstance.config.data = _objectSpread({}, this.chartInstance.config.data, {}, rest);\n    this.chartInstance.update();\n  }\n\n  renderChart() {\n    const _this$props3 = this.props,\n          options = _this$props3.options,\n          legend = _this$props3.legend,\n          type = _this$props3.type,\n          plugins = _this$props3.plugins;\n    const node = this.element;\n    const data = this.memoizeDataProps();\n\n    if (typeof legend !== 'undefined' && !isEqual(ChartComponent.defaultProps.legend, legend)) {\n      options.legend = legend;\n    }\n\n    this.chartInstance = new Chart(node, {\n      type,\n      data,\n      options,\n      plugins\n    });\n  }\n\n  destroyChart() {\n    // Put all of the datasets that have existed in the chart back on the chart\n    // so that the metadata associated with this chart get destroyed.\n    // This allows the datasets to be used in another chart. This can happen,\n    // for example, in a tabbed UI where the chart gets created each time the\n    // tab gets switched to the chart and uses the same data).\n    this.saveCurrentDatasets();\n    const datasets = Object.values(this.datasets);\n    this.chartInstance.config.data.datasets = datasets;\n    this.chartInstance.destroy();\n  }\n\n  render() {\n    const _this$props4 = this.props,\n          height = _this$props4.height,\n          width = _this$props4.width,\n          id = _this$props4.id;\n    return React.createElement(\"canvas\", {\n      ref: this.ref,\n      height: height,\n      width: width,\n      id: id,\n      onClick: this.handleOnClick,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 292\n      },\n      __self: this\n    });\n  }\n\n}\n\nChartComponent.getLabelAsKey = d => d.label;\n\nChartComponent.propTypes = {\n  data: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired,\n  getDatasetAtEvent: PropTypes.func,\n  getElementAtEvent: PropTypes.func,\n  getElementsAtEvent: PropTypes.func,\n  height: PropTypes.number,\n  legend: PropTypes.object,\n  onElementsClick: PropTypes.func,\n  options: PropTypes.object,\n  plugins: PropTypes.arrayOf(PropTypes.object),\n  redraw: PropTypes.bool,\n  type: function (props, propName, componentName) {\n    if (!Chart.controllers[props[propName]]) {\n      return new Error('Invalid chart type `' + props[propName] + '` supplied to' + ' `' + componentName + '`.');\n    }\n  },\n  width: PropTypes.number,\n  datasetKeyProvider: PropTypes.func\n};\nChartComponent.defaultProps = {\n  legend: {\n    display: true,\n    position: 'bottom'\n  },\n  type: 'doughnut',\n  height: 150,\n  width: 300,\n  redraw: false,\n  options: {},\n  datasetKeyProvider: ChartComponent.getLabelAsKey\n};\nexport default ChartComponent;","map":{"version":3,"sources":["/Users/macintosh/tugas-big-data/src/component/chartComponent.js"],"names":["React","PropTypes","Chart","isEqual","keyBy","ChartComponent","Component","constructor","handleOnClick","event","instance","chartInstance","props","getDatasetAtEvent","getElementAtEvent","getElementsAtEvent","onElementsClick","ref","element","undefined","componentDidMount","renderChart","componentDidUpdate","redraw","destroyChart","updateChart","shouldComponentUpdate","nextProps","type","options","plugins","legend","height","width","nextData","transformDataProp","shadowDataProp","componentWillUnmount","data","node","memoizeDataProps","datasets","map","set","saveCurrentDatasets","getCurrentDatasets","config","currentDatasets","forEach","d","datasetKeyProvider","helpers","configMerge","nextDatasets","checkDatasets","currentDatasetsIndexed","next","current","splice","length","point","pid","otherProps","rest","update","defaultProps","Object","values","destroy","render","id","getLabelAsKey","label","propTypes","oneOfType","object","func","isRequired","number","arrayOf","bool","propName","componentName","controllers","Error","display","position"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport Chart from 'chart.js';\nimport isEqual from 'lodash/isEqual';\nimport keyBy from 'lodash/keyBy';\n\nclass ChartComponent extends React.Component {\n    constructor() {\n      super();\n      this.chartInstance = undefined;\n    }\n  \n    static getLabelAsKey = d => d.label;\n  \n    static propTypes = {\n      data: PropTypes.oneOfType([\n        PropTypes.object,\n        PropTypes.func\n      ]).isRequired,\n      getDatasetAtEvent: PropTypes.func,\n      getElementAtEvent: PropTypes.func,\n      getElementsAtEvent: PropTypes.func,\n      height: PropTypes.number,\n      legend: PropTypes.object,\n      onElementsClick: PropTypes.func,\n      options: PropTypes.object,\n      plugins: PropTypes.arrayOf(PropTypes.object),\n      redraw: PropTypes.bool,\n      type: function(props, propName, componentName) {\n        if(!Chart.controllers[props[propName]]) {\n          return new Error(\n            'Invalid chart type `' + props[propName] + '` supplied to' +\n            ' `' + componentName + '`.'\n          );\n        }\n      },\n      width: PropTypes.number,\n      datasetKeyProvider: PropTypes.func\n    }\n  \n    static defaultProps = {\n      legend: {\n        display: true,\n        position: 'bottom'\n      },\n      type: 'doughnut',\n      height: 150,\n      width: 300,\n      redraw: false,\n      options: {},\n      datasetKeyProvider: ChartComponent.getLabelAsKey\n    }\n  \n    componentDidMount() {\n      this.renderChart();\n    }\n  \n    componentDidUpdate() {\n      if (this.props.redraw) {\n        this.destroyChart();\n        this.renderChart();\n        return;\n      }\n  \n      this.updateChart();\n    }\n  \n    shouldComponentUpdate(nextProps) {\n      const {\n        redraw,\n        type,\n        options,\n        plugins,\n        legend,\n        height,\n        width\n      } = this.props;\n  \n      if (nextProps.redraw === true) {\n        return true;\n      }\n  \n      if (height !== nextProps.height || width !== nextProps.width) {\n        return true;\n      }\n  \n      if (type !== nextProps.type) {\n        return true;\n      }\n  \n      if (!isEqual(legend, nextProps.legend)) {\n        return true;\n      }\n  \n      if (!isEqual(options, nextProps.options)) {\n        return true;\n      }\n  \n      const nextData = this.transformDataProp(nextProps);\n  \n      if( !isEqual(this.shadowDataProp, nextData)) {\n        return true;\n      }\n  \n      return !isEqual(plugins, nextProps.plugins);\n  \n  \n    }\n  \n    componentWillUnmount() {\n      this.destroyChart();\n    }\n  \n    transformDataProp(props) {\n      const { data } = props;\n      if (typeof(data) == 'function') {\n        const node = this.element;\n        return data(node);\n      } else {\n        return data;\n      }\n    }\n  \n    // Chart.js directly mutates the data.dataset objects by adding _meta proprerty\n    // this makes impossible to compare the current and next data changes\n    // therefore we memoize the data prop while sending a fake to Chart.js for mutation.\n    // see https://github.com/chartjs/Chart.js/blob/master/src/core/core.controller.js#L615-L617\n    memoizeDataProps() {\n      if (!this.props.data) {\n        return;\n      }\n  \n      const data = this.transformDataProp(this.props);\n  \n      this.shadowDataProp = {\n        ...data,\n        datasets: data.datasets && data.datasets.map(set => {\n          return {\n              ...set\n          };\n        })\n      };\n  \n      this.saveCurrentDatasets(); // to remove the dataset metadata from this chart when the chart is destroyed\n  \n      return data;\n    }\n  \n    // checkDatasets(datasets) {\n    //   const isDev = NODE_ENV !== 'production' && NODE_ENV !== 'prod';\n    //   const usingCustomKeyProvider = this.props.datasetKeyProvider !== ChartComponent.getLabelAsKey;\n    //   const multipleDatasets = datasets.length > 1;\n  \n    //   if (isDev && multipleDatasets && !usingCustomKeyProvider) {\n    //     let shouldWarn = false;\n    //     datasets.forEach((dataset) => {\n    //       if (!dataset.label) {\n    //         shouldWarn = true;\n    //       }\n    //     });\n  \n    //     if (shouldWarn) {\n    //       console.error('[react-chartjs-2] Warning: Each dataset needs a unique key. By default, the \"label\" property on each dataset is used. Alternatively, you may provide a \"datasetKeyProvider\" as a prop that returns a unique key.');\n    //     }\n    //   }\n    // }\n  \n    getCurrentDatasets() {\n      return (this.chartInstance && this.chartInstance.config.data && this.chartInstance.config.data.datasets) || [];\n    }\n  \n    saveCurrentDatasets() {\n      this.datasets = this.datasets || {};\n      var currentDatasets = this.getCurrentDatasets();\n      currentDatasets.forEach(d => {\n        this.datasets[this.props.datasetKeyProvider(d)] = d;\n      });\n    }\n  \n    updateChart() {\n      const {options} = this.props;\n  \n      const data = this.memoizeDataProps(this.props);\n  \n      if (!this.chartInstance) return;\n  \n      if (options) {\n        this.chartInstance.options = Chart.helpers.configMerge(this.chartInstance.options, options);\n      }\n  \n      // Pipe datasets to chart instance datasets enabling\n      // seamless transitions\n      let currentDatasets = this.getCurrentDatasets();\n      const nextDatasets = data.datasets || [];\n      this.checkDatasets(currentDatasets);\n  \n      const currentDatasetsIndexed = keyBy(\n        currentDatasets,\n        this.props.datasetKeyProvider\n      );\n  \n      // We can safely replace the dataset array, as long as we retain the _meta property\n      // on each dataset.\n      this.chartInstance.config.data.datasets = nextDatasets.map(next => {\n        const current =\n          currentDatasetsIndexed[this.props.datasetKeyProvider(next)];\n  \n        if (current && current.type === next.type && next.data) {\n          // Be robust to no data. Relevant for other update mechanisms as in chartjs-plugin-streaming.\n          // The data array must be edited in place. As chart.js adds listeners to it.\n          current.data.splice(next.data.length);\n          next.data.forEach((point, pid) => {\n            current.data[pid] = next.data[pid];\n          });\n          const { data, ...otherProps } = next;\n          // Merge properties. Notice a weakness here. If a property is removed\n          // from next, it will be retained by current and never disappears.\n          // Workaround is to set value to null or undefined in next.\n          return {\n            ...current,\n            ...otherProps\n          };\n        } else {\n          return next;\n        }\n      });\n  \n      const { datasets, ...rest } = data;\n  \n      this.chartInstance.config.data = {\n        ...this.chartInstance.config.data,\n        ...rest\n      };\n  \n      this.chartInstance.update();\n    }\n  \n    renderChart() {\n      const {options, legend, type, plugins} = this.props;\n      const node = this.element;\n      const data = this.memoizeDataProps();\n  \n      if(typeof legend !== 'undefined' && !isEqual(ChartComponent.defaultProps.legend, legend)) {\n        options.legend = legend;\n      }\n  \n      this.chartInstance = new Chart(node, {\n        type,\n        data,\n        options,\n        plugins\n      });\n    }\n  \n    destroyChart() {\n      // Put all of the datasets that have existed in the chart back on the chart\n      // so that the metadata associated with this chart get destroyed.\n      // This allows the datasets to be used in another chart. This can happen,\n      // for example, in a tabbed UI where the chart gets created each time the\n      // tab gets switched to the chart and uses the same data).\n      this.saveCurrentDatasets();\n      const datasets = Object.values(this.datasets);\n      this.chartInstance.config.data.datasets = datasets;\n  \n      this.chartInstance.destroy();\n    }\n  \n    handleOnClick = (event) => {\n      const instance = this.chartInstance;\n  \n      const {\n        getDatasetAtEvent,\n        getElementAtEvent,\n        getElementsAtEvent,\n        onElementsClick\n      } = this.props;\n  \n      getDatasetAtEvent && getDatasetAtEvent(instance.getDatasetAtEvent(event), event);\n      getElementAtEvent && getElementAtEvent(instance.getElementAtEvent(event), event);\n      getElementsAtEvent && getElementsAtEvent(instance.getElementsAtEvent(event), event);\n      onElementsClick && onElementsClick(instance.getElementsAtEvent(event), event); // Backward compatibility\n    }\n  \n    ref = (element) => {\n      this.element = element;\n    }\n  \n    render() {\n      const {height, width, id} = this.props;\n  \n      return (\n        <canvas\n          ref={this.ref}\n          height={height}\n          width={width}\n          id={id}\n          onClick={this.handleOnClick}\n        />\n      );\n    }\n}\n  \nexport default ChartComponent;  "]},"metadata":{},"sourceType":"module"}